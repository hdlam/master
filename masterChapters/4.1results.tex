\chapter{Experiments and Results}
\label{cha:ResearchAndResults}

{\it In this chapter, the results from the experiments will be presented and discussed. Section \ref{sec:results} contains the actual results created by running each scenario. The setup of the experiment is explained in section \ref{sec:experimentalSetup}, it explains the setup and which parameters have been used to run the experiments.
Section \ref{sec:discussion} will discuss the results seen in section \ref{sec:results}, and a discussion on the differences between the results from the simulator and the physical robots.}

\section{Experimental Plan}
\label{sec:experimentalPlan}

The results are created by writing to a text file in the form of a .csv file, which can be open directly by spreadsheet softwares. A .csv file is simply a text file with comma separated values, a row in the .csv file would correspond to a row in the spreadsheet, and a column in the spreadsheet software is separated by a comma in the .csv file.

The watcher software have no way to find the actual velocity of the robots, because the wheels still move when the robot is turning on the same spot. We want to find out if the position of each robot have changed over a given time interval.
The way the watcher software calculates the velocity of each robot is to save the old position of the robot, then compare it with the new position and see how far off it is.
The formula used to find the mean value of all the robots at a time step is defined as:
\begin{equation}
\label{eq:muvel}
\mu_{velocity} = \frac{1}{N} \Sigma_{i=1}^N (P_{i_{new}} - P_{i_{old}})
\end{equation}

where:
\\
$p_{i_{new}}$ = the new updated position of the robot
\\
$p_{i_{old}}$ = the old position of the robot from last time step
\\
$N$ = number of robots used, in this experiment $N = 4$ 
\\
$\mu_{velocity}$ = the mean of the velocities in that time step

The average distance seen in section \ref{sec:results} are calculated the same way for both the physical experiment and in the simulator. Each entity's position is found and compared with the position of all the other entities. The length of the distance between each of them are used to find the average and the standard deviation.
The formula to find 

\begin{equation}
\mu_{distances} = \frac{1}{ {N \choose R}} \Sigma_1^{N \choose R} | P_i - P_j |
\end{equation}

where:
\\
$P_i$ = the position of robot i, and $i \neq j$
\\
$P_j$ = the position of robot j, and $i \neq j$
\\
$N$ = the number of robots or Boids used
\\
$R$ = the amount of entities that are being compared each time, in this experiment we only measures the distance between two entities at the same time, therefore $R = 2$.
\\
$N \choose R$ = the combination operator, this corresponds to $ \frac{N!}{R! (N-K)!}$
\\
$\mu_{distances}$ = the mean of the compared distances in that time step
\\

The same procedure was applied for the angle of each entity: 
\begin{equation}
\mu_{angles} = \frac{1}{ {N \choose R}} \Sigma_1^{N \choose R} | A_i - A_j |
\end{equation}
where:
\\
$A_i$ = the angle of robot x, and $i \neq j$
\\
$A_j$ = the angle of robot y, and $i \neq j$
\\
$\mu_{angles}$ = the mean of the compared angles in that time step.
\\

To find the standard deviation of the velocity, the formula in equation \ref{eq:sd} was used, but a modification was done for the standard deviation of the distances and angles as seen in equation \ref{eq:sd2} because we had $ {N \choose R}$ number of distances and angles. The reason for $ {N \choose R}$ number of distances is because this is the number of comparisons between each robot. For these experiments, $N = 4$, and $R = 2$ because there is a comparison between two robot at the same time.


\begin{equation}
\label{eq:sd}
\sigma =  \sqrt{\frac{1}{N}\Sigma(X-\mu)^2}
\end{equation}

\begin{equation}
\label{eq:sd2}
\sigma =  \sqrt{\frac{1}{{N \choose R}}\Sigma(X-\mu)^2}
\end{equation}

%from template: Trying and failing is a major part of research. However, to have a chance of success you need a plan driving the experimental research, just as you need a plan for your literature search. Further, plans are made to be revised and this revision ensures that any further decisions made are in line with the work already completed. The plan should include what experiments or series of experiments are planned and what question the individual or set of experiments aim to answer. Such questions should be connected to your research questions so that in the evaluation of your results you can discuss the results wrt to the research questions.  

\section{Experimental Setup}
\label{sec:experimentalSetup}
In this section, the setup for the experiment will be explained, and which parameters have been used to run the experiments. 

In this experiment, four robots and one obstacle is used inside a sandbox. Each robots needs to have an extra layer on top of them so the red and green post it note does not fall off as seen in figure \ref{fig:robot0}. The robots moves inside a sandbox, which is watched by a web camera from above.
In the simulator, the following parameters have been used:
\begin{description}
\item[cohesion distance] = 250 px
\item[alignment distance] = 175 px
\item[separation distance] = 120 px
\item[away from wall distance] = same as alignment
\item[obstacle distance] = same as separation
\end{description}
This distances tells the Boid how near it has to be before it should calculate the vector. For example if the Boid is in the middle of the screen, that means that it is not near a wall, then the "away from wall" function will return the null vector because it does not need the Boid to steer away from the wall.
The numbers given over is the furthest distance that the Boid will consider, for instance a Boid that have three neighbors, where one of them is 100 px away, the second one is  while the third one is 300 px away. The first Boid will be taken into consideration when calculating all of the three behaviors; cohesion, alignment and separation because it is very close. The second Boids will not have any influence on the separation behavior, but it will influence the alignment and cohesion vector. The third one is too far away, and will be ignored when calculating the three behaviors. These distances are illustrated in figure \ref{fig:simulatordistances}.
The Boids in the simulator has a velocity cap of 40 px per frame, moving faster than 40 px would make the Boids move too fast, and it would be hard to clearly see the details of the movements. 

Each vector from each behavior is multiplied with a factor that determines how much impact that vector will have on the final acceleration vector.
The list provided below is the weight multiplied by the behavior vector. Or $W_x$ found in equation \ref{eq:vecsum}.
\begin{description}
\item[cohesion] vector is multiplied by 2
\item[alignment] vector is multiplied by 2
\item[away from wall] vector is multiplied by 2
\item[avoid obstacles] vector is multiplied by 3
\item[separation] vector is multiplied by 3
\end{description}

As seen in the list above, the two vectors that have the highest influence on the robot is the separation and the obstacle avoidance behavior. These two behaviors needs to influence the robot a lot more than the other behaviors because they are only activated when the robot is very close to another robot or an obstacle.

The robots on the other hand had different parameters for their behaviors:
\begin{description}
\item[cohesion distance] = 800 px
\item[alignment distance] = 200 px
\item[separation distance] = 150 px
\item[away from wall distance] = same as alignment
\item[obstacle distance] = same as separation
\end{description}

The reason the cohesion distance for the physical robot are so different than the one in the simulator is because the robots are slow to flock together and they might get stuck at a corner when the sensors, so a big cohesion distance makes the robots flock together faster. If the robots' cohesion distance were to be the same as the cohesion distance for the simulated Boids, they might stay too long in one place, and the robots might not flock. As shown in later sections, the robots flocks with an average distance of 200 px, therefore the cohesion distance has to be sufficient larger than 200 px for it to be effective. 

The Boids in the simulator do not need a cohesion distance of 800, because they wander a lot around even if there is no neighboring Boids around them. When they have wandered around for a while, they will eventually find another Boid that is near enough and they will start to flock together.

The simulator was intended to handle a lot more than the four Boids used in this project. If the Boids had a longer cohesion distance, more Boids would flock together and the sub flock emergence would not occur as much as seen in figure \ref{fig:simulatordistances}.

The weights on the behavior vectors for the robots are a little bit different than the one found in the simulator.
\begin{description}
\item[cohesion] vector is multiplied by 2
\item[alignment] vector is multiplied by 2
\item[away from wall] vector is multiplied by 1
\item[avoid obstacles] does not exist
\item[separation] vector is multiplied by 4
\end{description}

The reason the avoid obstacle vector does not exist, is because the watcher software can not find nor distinguish obstacle from the surroundings. This feature is not implemented in the camera tracking software. The robot needs to know the size of the sandbox beforehand, because the camera or the watcher software do not provide this information to the robot. To compensate for the lack of obstacle information, the robot uses their distance sensors to find out where the obstacle are located and avoids them.

The separation vector is multiplied with a weight of 4 for the robot, but only multiplied with a weight of 3 for the Boids. There is no specific reason for this, after testing it seems to perform better with a weight of 4 on separation instead of 3.
With a weight of 3 on separation the Robots bumped into each other quite often, that is why the weight for the separation have been increased to 4.

The camera used in this experiment is a web camera. To be able to get a clear stable video feed images from the web camera, the settings for the camera had to be manually set up.
The most important setting is to disable auto focus. Auto focus makes the images blurry, and the camera tracking software will not be able to detect red and green colors which defines the robots. 50 Hz power line frequency was used instead of 60 Hz to eliminate flickering on the camera feed. The other settings are not that important, as long as the web camera is able to provide a decent looking image that the camera tracker software is able to recognize.



%The experimental setup should include all data - parameters etc, that would allow a person to repeat your experiments. 


\section{Results}
\label{sec:results}

The Boids algorithm are supposed to keep the robots flocked together and preferably they should face the same direction as well. The watcher knows where each robot is, and it knows which direction each robot is facing. The watcher measures the distance between each robot and the angle difference between the robots every five frame or twelve times each second, it then calculates the mean and standard deviation of the distances and angles and saves it to a file. The mean and standard deviation of the velocity is recorded as well, in the simulator the velocity is measured directly by getting the velocity vector on each object, for the physical robot, the change in position is measured instead.

To keep the data as consistent between each run the watcher stops all the robots and saves the data file exactly three minutes or 180,000 milliseconds after the robots have started to move.
The distance measured are in pixels. The measurement of the sandbox is 151.6 cm wide and 123.9 cm long. The watcher software creates a window that has a resolution 800x652 pixels, which means that 1 cm is approximately 5.3 pixels on the screen. The measured angles are shown in radians.

In the upcoming figures, the results from the various runs will be shown. On the x-axis the time will be shown, and the y-axis displays various types of data is presented depending on the figure. The time shown on the x-axis displays the iteration, and not seconds. One iteration is five frames, the software runs with a 60 frames per second. Which means that twelve iterations on the x-axis corresponds to one second. The velocity is measured every iteration, the velocity graph is mostly used as an indication to whether the robots are moving or not. The velocity graphs can be used as an indication whether the robots are moving fast or slower, but it can not be used to reliably tell the velocity of the robots. The velocity graph for the simulated Boids are more precise.
The number shown on the y-axis shows the average length of the velocity vector for each Boid.

The upcoming figures will show graphs of various types, two similar ones will be displayed for each scenario. One is the results from ten runs on the physical experiment with the robots, and the other one is the results from the experiments ran in simulation. In section \ref{sec:discussion} a discussion of the results will be presented, it will contain an explanation as to why some of the graphs might be different.

\subsection{Results from scenario 1}
\label{sec:res1}
\begin{figure}[h]
\begin{center}
\includegraphics[width=0.8\linewidth]{figs/runs/1pdist}
\end{center}
\caption[1. Distances, robots]{Results from 10 runs averaged on scenario 1, robots}
\label{fig:res1pdist}
\end{figure}
\begin{figure}[h]
\begin{center}
\includegraphics[width=0.8\linewidth]{figs/runs/1sdist}
\end{center}
\caption[1. Distances, simulation]{Results from 5 runs averaged on scenario 1, simulator}
\label{fig:res1sdist}
\end{figure}
The first scenario was designed to check if the robots were able to flock together, the robots were placed on each of its corner, as far from each other as possible.
From the figure \ref{fig:res1pdist} we can see that the robots are flocking together quite fast, they start out on each corner of the sandbox then move towards the center of the sandbox, this is shown in the graph by the first drop from 700 px to around 200 px. This corresponds to roughly 132 cm to 37 cm. The time it takes for the graph to drop from 700 px to 200 px is around 300 iterations, which equals 25 seconds.
The simulated Boids behave differently in the same scenario, as seen from figure \ref{fig:res1sdist}, between time step 40 and 305, the graph shows a local maxima. Because all of the Boids are moving towards the middle due to the velocity they have at the start, the distance between them will decrease. But one of the Boids is moving directly toward the obstacle and facing it directly, when it comes too close, it will be "pushed" directly in the opposite direction. The Boid that is being "pushed" in the opposite direction by the obstacle is too far away from the other Boids for the cohesion behavior to be active, and therefore moves away from the rest of the flock. This is the reason there is a peak in the graph.

\begin{figure}[h]
\begin{center}
\includegraphics[width=0.8\linewidth]{figs/runs/1pangle}
\end{center}
\caption[1. Angle, robots]{Results from 10 runs averaged on scenario 1, robots}
\label{fig:res1pang}
\end{figure}
\begin{figure}[h]
\begin{center}
\includegraphics[width=0.8\linewidth]{figs/runs/1sangle}
\end{center}
\caption[1. Angle, Simulation]{Results from 5 runs averaged on scenario 1, simulator}
\label{fig:res1sang}
\end{figure}



\begin{figure}[h]
\begin{center}
\includegraphics[width=0.8\linewidth]{figs/runs/1pvel}
\end{center}
\caption[1. Velocity, robots]{Results from 10 runs averaged on scenario 1, robots}
\label{fig:res1pvel}
\end{figure}
\begin{figure}[h]
\begin{center}
\includegraphics[width=0.8\linewidth]{figs/runs/1svel}
\end{center}
\caption[1. Velocity, simulation]{Results from 5 runs averaged on scenario 1, simulator}
\label{fig:res1svel}
\end{figure}






\clearpage
\subsection{Results from scenario 2}
\label{sec:res2}
\begin{figure}[h]
\begin{center}
\includegraphics[width=0.8\linewidth]{figs/runs/2pdist}
\end{center}
\caption[2. Distances, robots]{Results from 10 runs averaged on scenario 2, robots}
\label{fig:res2pdist}
\end{figure}
\begin{figure}[h]
\begin{center}
\includegraphics[width=0.8\linewidth]{figs/runs/2sdist}
\end{center}
\caption[2. Distances, simulation]{Results from 5 runs averaged on scenario 2, simulator}
\label{fig:res2sdist}
\end{figure}
In the second scenario, three of the robots are already in a flock while the fourth one is astray from the flock on the other side of the sandbox. The three robots that have already flocked together will try to stay together, they do not want to move all the way to the other side to flock with one single robot. If all of the robots were moving, the single robot would move towards the three robots and they all would together faster.
When running scenario 2 on the simulator, the Boids move towards the obstacle and around it. When they are near enough to the non-moving Boids, the cohesion behavior will activate and the Boids will try to flock, but due to all the other behaviors, the three moving Boid will be pushed away. After being pushed away, they will keep moving in the same direction and move all the way around the screen.

\begin{figure}[h]
\begin{center}
\includegraphics[width=0.8\linewidth]{figs/runs/2pangle}
\end{center}
\caption[2. Angle, robots]{Results from 10 runs averaged on scenario 2, robots}
\label{fig:res2pang}
\end{figure}
\begin{figure}[h]
\begin{center}
\includegraphics[width=0.8\linewidth]{figs/runs/2sangle}
\end{center}
\caption[2. Angles, robots]{Results from 5 runs averaged on scenario 2, simulator}
\label{fig:res2sang}
\end{figure}
\begin{figure}[h]
\begin{center}
\includegraphics[width=0.8\linewidth]{figs/runs/2pvel}
\end{center}
\caption[2. Velocity, robots]{Results from 10 runs averaged on scenario 2, robots}
\label{fig:res2pvel}
\end{figure}
\begin{figure}[h]
\begin{center}
\includegraphics[width=0.8\linewidth]{figs/runs/2svel}
\end{center}
\caption[2. Velocity, robots]{Results from 5 runs averaged on scenario 2, simulator}
\label{fig:res2svel}
\end{figure}








\clearpage
\subsection{Results from scenario 3}
\label{sec:res3}
\begin{figure}[h]
\begin{center}
\includegraphics[width=0.8\linewidth]{figs/runs/3pdist}
\end{center}
\caption[3. Distances, robots]{Results from 10 runs averaged on scenario 3, robots}
\label{fig:res3pdist}
\end{figure}
\begin{figure}[h]
\begin{center}
\includegraphics[width=0.8\linewidth]{figs/runs/3sdist}
\end{center}
\caption[3. Distances, simulation]{Results from 5 runs averaged on scenario 3, simulator}
\label{fig:res3sdist}
\end{figure}

The results for the distances between the robots in the third scenario is similar to the one in the first. They move closer to each other, and then stay as a flock for the rest of the time. In the simulator, the Boids starts by moving further away from each other, before converging together.
The Boids that starts on the lower right are behind an obstacle, which pushes it away from the other ones. The lower left Boid has a start velocity away from the robots, and due to the short cohesion distance radius, it will move away from the other Boids. The other Boids are not in range for the cohesion behavior to activate.
However it does not take too long before the Boids are able to flock together, as seen from figure \ref{fig:res3sdist} the robots are starting to move towards each other after 40 time steps, and are fully flocked together at time step 150. 
The robots does not have the same behavior as the Boids in this scenario, and they have a much wider cohesion distance. Obstacles do not push the robots in the opposite direction either, when a robot tries to figure out which direction it is going to move in, it will ignore the wall and obstacles. If there is an obstacle in front of a robot, it will turn away from the obstacle. But the next time it calculates where it wants to go, it might calculate the direction it want to go is through the obstacle, thus the robot will turn toward the obstacle then realize that there is in fact an obstacle in front of it and it has to turn away. The robot might get stuck because of this turning behavior, but it will eventually force itself to move around the obstacle. In the mean time, the other robots will move towards the robot that has been stuck behind the obstacle.

\begin{figure}[h]
\begin{center}
\includegraphics[width=0.8\linewidth]{figs/runs/3pangle}
\end{center}
\caption[3. Angle, robots]{Results from 10 runs averaged on scenario 3, robots}
\label{fig:res3pang}
\end{figure}
\begin{figure}[h]
\begin{center}
\includegraphics[width=0.8\linewidth]{figs/runs/3sangle}
\end{center}
\caption[3. Angle, robots]{Results from 5 runs averaged on scenario 3, simulator}
\label{fig:res3sang}
\end{figure}
\begin{figure}[h]
\begin{center}
\includegraphics[width=0.8\linewidth]{figs/runs/3pvel}
\end{center}
\caption[3. Velocity, robots]{Results from 10 runs averaged on scenario 3, robots}
\label{fig:res3pvel}
\end{figure}
\begin{figure}[h]
\begin{center}
\includegraphics[width=0.8\linewidth]{figs/runs/3svel}
\end{center}
\caption[3. Velocity, robots]{Results from 5 runs averaged on scenario 3, simulator}
\label{fig:res3svel}
\end{figure}

\clearpage
\section{Discussion}
\label{sec:discussion}
This section will mainly focus on explaining the data from the results, why there is a difference between the physical experiment and the experiments done in a simulator.

%See figure \ref{fig:scene1peakillustrated}. %TODO
%\begin{figure}[h]
%\begin{center}
%\includegraphics[width=0.8\linewidth]{figs/scene1_pushedaway2}
%\end{center}
%\caption[3. Velocity, robots]{Results from 10 runs averaged on scenario 3, simulator}
%\label{fig:scene1peakillustrated}
%\end{figure}

The distances converges to 200 px in about 300-400 time steps for the robots in the first scenario and the third scenario. It takes a bit longer for the distance to drop to 200 px in the second scenario, around 1310 time steps, which is approximately 110 seconds. In the first and third scenario, the robots' distance converges to 200 px, and the simulator converges to 150 px. These numbers comes from the behaviors explained in section \ref{sec:experimentalSetup}. The separation distance is 120 px, so the Boids will try to stay around 120 px away from the other Boids. The same goes for the robot, but due to the distance sensors used for avoiding obstacles, they tend to stay further away from the other robots. 

In the first and third scenario, each robot starts alone. Due to this, only the sensors used for obstacle avoidance, the "away from wall" and the cohesion behavior will be active. This makes each of the robot move towards the other ones, and the robots converge to a flock faster. 

%//angle
The angles measured seems to vary a lot, even if the alignment behavior tries to make all the robots face the same way. But the overall trend of the robots seems to be that the angles lingers around 1.5 radians on average for all three scenarios, which is pretty high.

The simulated Boids are able to face in the same direction as the other Boids, starting with an angle difference of 2 radians and slowly dropping down to 0.5 radians. This holds true on the graphs shown for the first and third scenario. The angles in second scenario are varying a lot, ranging from 0.4 radians to 1.6. This happens because one of the Boid is not moving, its angle is always 0. While the other three is moving around and their will range from $-\pi$ to $\pi$ depending on the direction they are moving.

If the allowed space to travel were bigger, and there were no obstacles. The Boids would be able to move without needing to turn, and the angle between them would stay consistently low. However the allowed space for the robots to travel is limited and there is an obstacle there as well.
Whenever the robots detects an obstacle or move towards the walls, the distance sensors will make the robot turn around so the robot will not crash. Sometimes the robots will think that the other robots around itself are obstacles as well, because it has no way to tell the difference between the robots from an actual obstacle. This is because the distance sensors can not distinguish anything, it only measures a distance and the robots will try to avoid anything that is too near it, thinking that the object it detects is an obstacle.

The velocity for the robot varies a lot, we can see from the graph that the velocity varies from 0 to 6.3. The watcher software logs the velocity data by finding the change in position between two time steps, that is it finds $\Delta P$ as shown in equation \ref{eq:calcrobvel} of each robot every iteration. When a robot is turning to change direction or to avoid an obstacle, it is not moving because it is just spinning in place. 
The Boids in the simulator never stops, that is the velocity never drops down to 0, they keep moving in different direction all the time. Being able to move freely in all 360\textdegree\ almost instantly. They do not need to stop to change direction.
The physical ChIRP robot needs to turn around before moving in a new direction. As long as the new direction is off by an angle larger than 1\textdegree\ from the angle the robot is currently facing, then it will stop and turn. All turning takes approximately one second, before the robot is moving again. If the robot will turn a lot, it will only have one second to do so, before it has to move. If it only needs to turn 2\textdegree, it will turn first and wait until it has been one second before moving on.
The one second delay is introduced to keep the timing somewhat synchronous between the robots, one second delay is long enough for the robot to be able to almost turn all the way around (180\textdegree). 

Whenever the robot turns, the watcher will not see any change in position, which is the method it uses to log the velocity of the robots. The watcher will therefore log that the velocity of the robot is 0 when the robots turn around on the same spot. 

The graphs only shows the average distance between the robots, the velocity of the robots and the difference between their angle. The graphs do not show where the robots are moving or whether they have crashed into anything.
Sometimes the robots do bump into the obstacles, or the other robots. The reason is that the robots measures the distances before moving, and not continuously while moving. So if a robot measures the distance in front of it and there is no obstacle in front of it, it will start to move forward. When the robot moves forward it might hit an obstacle or robot if the object is too close to it when it measures the distance. Sometimes robots moves onto the path of another robot while the other robot is moving, the other robot will probably bump into the one blocking its path. The robots do not crash into each other, that is they do not push each other around when they are trying to occupy the same space as the other robots. When the robots bump into each other, they nudge each other and might scrape against the surface of each other. However none of the paper taped on the robot has been torn apart when the robots were scraping against each other while running the experiment.

The robots only moves forward, and they only turn when they need to change direction or if there is an object in front of it that it needs to avoid. Sometimes the robots suddenly stops and rotates on the spot as if there is some sort of object in front of it, even if there is none.

The distance measured by the robot's sensors might be imprecise, due to disturbances around in the room that makes the measured distances imprecise. The disturbances can come from the infrared light the other robots sends out when they are measuring distances themselves, which might bounce around in the sandbox and disturb the other robots. 

For the camera to see the two colored post it notes on the robots, the room needs to be well lit. Extra lights were placed around the sandbox to lit it up. The room where the experiment took place had two large windows, by daytime the sun would shine into the room. The sunlight contains infrared light, if the sun shines into the room and hits the area where the robots roam, the robot will sense the infrared lights from the sunshine and think that there is an object in front of it. The blinds in the room were closed, but some of the sun would always shine into the room.
